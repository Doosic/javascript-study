# 원시 값과 객체의 비교

- 자바스크립트가 제공하는 7가지 타입(숫자,문자열,불리언,null,undefined,심벌,객체)은 크게
  원시 타입과 객체 타입으로 구분이 가능하다.
  - 1.원시 타입의 값, 즉 원시 값은 변경 불가능한 값이다. 이에 비해 객체(참조) 타입의 값, 즉 객체는 변경 가능한 값이다.
  - 2.원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장된다. 이에 비해 객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 참조 값이
    저장된다.
  - 3.원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 값에 의한 전달(pass by value)이라한다.
  - 4.이에 비해 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한
      전달(pass by reference)이라고 한다.

## 원시값

### 변경 불가능한 값

- 원시 타입의 값, 즉 원시 값은 변경 불가능한 값이다. 다시 말해, 한번 생성된 원시 값은 읽기 전용 값으로서 변경할 수 없다.
- 변수는 하나의 값을 저장하기 위해 확보된 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이고, 값은 변수에 저장된
  데이터로써 표현식이 평가되어 생성된 결과를 말한다. 변경 불가능하다는 것은 변수가 아니라 값에 대한 진술이다.
- 원시 값이 변경 불가능하다는 것은 원시 값 자체를 변경 불가능 하다는 것이지 변수 값을 변경할 수 없다는 것이 아니다.
```
// const 키워드를 사용해 선언한 변수는 재할당이 금지된다. 상수는 재할당이 금지된 변수일 뿐이다.
const o = {};

// const 키워드를 사용해 선언한 변수에 할당한 원시 값(상수)은 변경할 수 없다.
// 하지만 const 키워드를 사용해 선언한 변수에 할당한 객체는 변경할 수 있다.
o.a = 1;
console.log(o); // {a: 1}
```
- 원시값이 재할당되는 것처럼 보이지만 사실은 새로운 메모리 공간을 확보하고 재할당한 원시값을 저장한 후, 변수는
  새롭게 저장한 원시값의 주소 참조하는 것이다.
- 이러한 값의 특성을 불변성이라고 한다.(immutabillity)
- **불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.** 만약
  재할당 이외에 원시 값인 변수 값을 변경할 수 있다면 예기치 않게 변수 값이 변경될 수 있다는 것을 의미한다.
  이는 값의 변경, 즉 상태 변경을 추적하기 어렵게 만든다.

### 문자열과 불변성

- 원시값을 저장하려면 먼저 확보해야하는 메모리 공간의 크기를 결정해야 한다. 이를 위해 원시타입별로 메모리 공간의
  크기가 미리 정해져있다. 문자열(2바이트), 숫자타입(8바이트)
- 숫자값은 1도, 100000도 동일한 8바이트가 필요하지만 문자열의 경우(단순히 계산했을때) 1개의 문자열로 이뤄진 문자열은 20바이트
  가, 10개의 문지로 이뤄진 문자열은 20바이트가 필요하다. 
- 자바스크립트의 문자열은 원시타입이다.
- 자바스크립트의 문자열은 유사 배열 객체이다. 유사배열 객체란 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고
  length 프로퍼티를 갖는 객체를 말한다. 때문에 for문으로 순회도 가능하다.
- 문자열은 원시값이기에 문자열 재할당이 아닌 새롭게 할당후 가리키는 주소를 변경하는것이다.

### 값에 의한 전달

- 변수에 원시값을 갖는 변수를 할당하면 할당받는 변수에는 할당되는 변수의 원시값이 복사되어 전달된다. 이를 **값에 의한 전달**
  이라고 한다.
- 값에 의한 전달로 받은 값은 값이 갖다는 것이 동일하다. 그러나 각각의 변수가 값은 같아도 다른 메모리 공간에 저장된 별개의 값이다.
```
var score = 80;
var copy = score;

console.log(scire, copy);  // 80
console.log(score === copy);  // 80
```
- 서로 별개의 값이기에 어느 한쪽의 데이터에 값을 변경해도 다른 한쪽에 값에는 아무런 영향도 끼치지 못한다.
- 파이썬 같은 경우에는 변수가 어느 변수를 카피했을때에 둘이 같은 메모리 주소를 바라보다가 한쪽의 데이터가 변경될때에 다른
  메모리 주소에 값을 할당하는 방식을 사용한다고 한다.
- "값에 의한 전달"이라는 용어는 사실 자바스크립트를 위한 용어가 아니다. 엄격하게 표현하자면
  변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달되기 때문이다. 이는 변수와 같은 식별자는 값이 아니라
  메모리 주소를 기억하고 있기 때문이다.
```
var x = 10;
```
- 위의 경우 할당 연산자는 숫자 리터럴 10에 의해 생성된 숫자 값 10이 저장된 메모리 공간의 주소를 식별자에게 전달한다.
  이로써 식별자 x는  메모리 공간에 저장된 숫자 값 10을 식별할 수 있다.
- **"값의 의한 전달"도 사실은 값을 전달 하는 것이 아니라 메모리 주소를 전달한다. 단, 전달된 메모리
  주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.**
#### 중요!!!
- 중요한 것은 변수에 원시 값을 갖는 변수를 할당하면 변수 할당 시점이든, 두 변수 중 어느 하나의 변수에 값을 재할당하는 시점이든
  **결국은 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해
  값을 변경하더라도 서로 간섭할 수 없다는 것이다.**
<hr>

## 객체

- 객체는 프로퍼티의 개수가 정해쟈 있지 않으며, 동적으로 추가되고 삭제할 수 있다. 또한 프로퍼티의 값에도 제약이 없다
  따라서 객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.
- 자바스크립트는 해시 테이블이 아닌 히든 클래스라는 방식을 사용하여 C++ 객체의 프로퍼티에 접근하는 정도의 성능을 보장한다.

### 변경 가능한 값

- 객체(참조) 타입의 값, 즉 객체는 변경 가능한 값 이다.
```
var person = {
  name: 'Lee'
};
```
- 원시 값은 변수에 저장된 메모리 주소를 통해 메모리에 접근하면 원시값에 접근 할 수 있다.
- 객체값은 변수에 저장된 메모리 주소를 통해 메모리에 접근하면 참조 값에 접근할 수 있고 참조 값(객체가 저장된 메모리 주소)을 통하여
  객체가 저장된 메모리 공간에 접근할 수 있다. 참조 값은 생성된 객체가 저장된 메모리 공간의 주소, 그 자체다.
```
// 원시값
var cost = 5;
cost => 0x00000F2(값 5가 저장되어 있다.)

// 객체값
var cost = {
  age: 5
};
cost => 0x0000F2(참조값 즉, 객체의 주소가 저장되어있다: 0x0000F5) => 0x0000F5(객체의 프로퍼티 age: 5)
```
#### OFFSET(오프셋) : 기준 주소에서 얼마만큼 떨어진 주소를 가르키는지, 즉 상대적 거리를 나타낼때 쓰는 말이다.

```
var person = {
  name: 'Lee'
};

// person 변수에 저장되어 있는 참조 값으로 실제 객체에 접근한다.
console.log(person); // {name: 'Lee'}
```

- 원시값은 변경 불가능한 값이므로 원시 값을 갖는 변수의 값을 변경하려면 재할당 외에는 방법이 없다. 하지만
  객체는 변경 가능한 값이다. 따라서 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다. 즉,
  재할당 없이 프로퍼티를 동적으로 추가할 수도 있고 프로퍼티 값을 갱신할 수도 있으며 프로퍼티 자체를 삭제할 수도 있다.
```
var person = {
  name: 'Lee'
};

// 프로퍼티 값 갱신
person.name = 'Kim';

// 프로퍼티 동적 생성
person.address = 'Seoul';

console.log(person); // {name: 'Kim', address: 'Seoul'}
```

#### 객체는 왜 참조로 사용하는가?

- 원시값 처럼 객체를 변경할 때 마다 이전 값을 복사해서 새롭게 생성한다면 명확하고 신뢰성이 확보되겠지만
  객체는 크기가 매우 클 수 도 있고, 원시 값처럼 크기가 일정하지도 않으며, 프로퍼티 값이 객체일 수도 있어서 복사해서
  생성하는 비용이 많이 든다. 다시 말해, **메모리의 효율적 소비가 어렵고 성능이 나빠진다**
- 따라서 메모리를 효율적으로 사용하기 위해, 그리고 객체를 복사해 생성하는 비용을 절약하여 성능을 향상시키기 위해
  객체는 변경 가능한 값으로 설계되어 있다. 메모리의 사용성과 효율성을 위해 어느 정도의 구조적인 단점을 감안한 설계이다.
- 객체는 이러한 구조적 단점에 따른 부작용이 있다. **원시 값과는 다르게 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이다.**

#### 얕은 복사와 깊은 복사
- 객체를 프로퍼티 값으로 갖는 객체의 경우 얕은 복사는 한 단계까지만 복사하는 것을 말하고 깊은 복사는 객체에 중첩되어있는
  객체까지 모두 복사하는 것을 말한다. 얕은 복사와 깊은 복사 둘다 원본과는 다른 객체이다.
  - 1.얕은 복사는 원본과 참조 값이 다르다 그러나 참조 값만 다르지 참조 값이 가지고있는 객체의 주소는 원본과 같기 떄문에 수정시
    객체를 참조하고 있는 값들에 영향을 끼칠수 있다.
  - 2.깊은 복사는 참조 값도 달라지고 객체값도 달라져 완전한 복사가 가능하다.

### 참조에 의한 전달

- 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 **참조에 의한 전달**이라 한다.
- <img width="500px" height="500px" src="https://user-images.githubusercontent.com/82255957/231643114-22115011-064b-427d-8f31-79b7ff228432.jpg">
- 위의 이미지와 같이 person과 copy가 저장된 메모리는 다르지만 동일한 참조 값을 갖는다. 다시 말해 원본과 사본 둘다
  동일한 객체를 가리킨다. 이것은 **두 개의 식별자가 하나의 객체를 공유한다는것**을 의미한다.
- 따라서 원본 또는 사본 중 어느 한쪽에서 객체를 변경하면 서로 영향을 주고받는다.

```
var person1 = {
  name: 'Lee'
};

var person1 = {
  name: 'Lee'
};

console.log(person1 === person2); // false 메모리의 주소값이 다르다.
console.log(person1.name === person2.name); // true 원시값이 같다.
```